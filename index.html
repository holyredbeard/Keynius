<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Piano</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .piano-container {
            perspective: 1000px;
        }
        
        .white-key {
            position: relative;
            width: 60px;
            height: 250px;
            background: white;
            border: 1px solid #ccc;
            border-radius: 0 0 5px 5px;
            box-shadow: 0 5px 5px rgba(0,0,0,0.2);
            transition: all 0.1s;
            z-index: 1;
        }
        
        .white-key.active {
            background: #f0f0f0;
            transform: translateY(2px);
            box-shadow: 0 3px 3px rgba(0,0,0,0.2);
        }
        
        .black-key {
            position: absolute;
            width: 36px;
            height: 150px;
            background: #222;
            border-radius: 0 0 3px 3px;
            box-shadow: 0 5px 5px rgba(0,0,0,0.4);
            z-index: 2;
            transition: all 0.1s;
        }
        
        .black-key.active {
            background: #111;
            transform: translateY(2px);
            box-shadow: 0 3px 3px rgba(0,0,0,0.4);
        }
        
        .key-label {
            position: absolute;
            bottom: 10px;
            width: 100%;
            text-align: center;
            font-size: 12px;
            color: #666;
        }
        
        .black-key .key-label {
            color: #aaa;
        }

        /* Loading indicator animation */
        .loading-indicator::after {
            content: '.';
            animation: loading-dots 1.5s steps(3, end) infinite;
            display: inline-block; /* Needed for animation */
            vertical-align: bottom;
            width: 1em; /* Reserve space to prevent layout shift */
            text-align: left;
        }

        @keyframes loading-dots {
            0%, 20% {
                content: '.';
            }
            40% {
                content: '..';
            }
            60%, 100% {
                content: '...';
            }
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex flex-col items-center justify-center p-4">
    <div class="text-center mb-8">
        <h1 class="text-4xl font-bold text-gray-800 mb-2">Keynius the AI Composer</h1>
        <p class="text-gray-600">Describe a song or style — Keynius plays it live on the piano.</p>
    </div>
    
    <div class="piano-container mb-8">
        <div class="flex relative">
            <!-- Lowest octave (C3-B3) - Mouse Only -->
            <div class="white-key" data-note="C3">
                <div class="key-label">(C3)</div>
            </div>
            <div class="white-key" data-note="D3">
                <div class="key-label">(D3)</div>
            </div>
            <div class="white-key" data-note="E3">
                <div class="key-label">(E3)</div>
            </div>
            <div class="white-key" data-note="F3">
                <div class="key-label">(F3)</div>
            </div>
            <div class="white-key" data-note="G3">
                <div class="key-label">(G3)</div>
            </div>
            <div class="white-key" data-note="A3">
                <div class="key-label">(A3)</div>
            </div>
            <div class="white-key" data-note="B3">
                <div class="key-label">(B3)</div>
            </div>
            <!-- Mid keys C4-B4 -->
            <div class="white-key" data-note="C4" data-key="z">
                <div class="key-label">(C4)</div>
            </div>
            <div class="white-key" data-note="D4" data-key="x">
                <div class="key-label">(D4)</div>
            </div>
            <div class="white-key" data-note="E4" data-key="c">
                <div class="key-label">(E4)</div>
            </div>
            <div class="white-key" data-note="F4" data-key="v">
                <div class="key-label">(F4)</div>
            </div>
            <div class="white-key" data-note="G4" data-key="b">
                <div class="key-label">(G4)</div>
            </div>
            <div class="white-key" data-note="A4" data-key="n">
                <div class="key-label">(A4)</div>
            </div>
            <div class="white-key" data-note="B4" data-key="m">
                <div class="key-label">(B4)</div>
            </div>
            <!-- Upper keys C5-B5 -->
            <div class="white-key" data-note="C5" data-key="q">
                <div class="key-label">(C5)</div>
            </div>
            <div class="white-key" data-note="D5" data-key="w">
                <div class="key-label">(D5)</div>
            </div>
            <div class="white-key" data-note="E5" data-key="e">
                <div class="key-label">(E5)</div>
            </div>
            <div class="white-key" data-note="F5" data-key="r">
                <div class="key-label">(F5)</div>
            </div>
            <div class="white-key" data-note="G5" data-key="t">
                <div class="key-label">(G5)</div>
            </div>
            <div class="white-key" data-note="A5" data-key="y">
                <div class="key-label">(A5)</div>
            </div>
            <div class="white-key" data-note="B5" data-key="u">
                <div class="key-label">(B5)</div>
            </div>
            
            <!-- Black keys -->
            <!-- Lowest Octave (C#3-A#3) - Mouse Only -->
            <div class="black-key" style="left: 42px;" data-note="C#3">
                 <div class="key-label">(C#3)</div>
            </div>
            <div class="black-key" style="left: 102px;" data-note="D#3">
                 <div class="key-label">(D#3)</div>
            </div>
            <div class="black-key" style="left: 222px;" data-note="F#3">
                 <div class="key-label">(F#3)</div>
            </div>
            <div class="black-key" style="left: 282px;" data-note="G#3">
                 <div class="key-label">(G#3)</div>
            </div>
            <div class="black-key" style="left: 342px;" data-note="A#3">
                 <div class="key-label">(A#3)</div>
            </div>
            <!-- Mid Octave (C#4-A#4) - Keys: S D G H J -->
            <div class="black-key" style="left: 462px;" data-note="C#4" data-key="s"> <!-- 42 + 420 -->
                <div class="key-label">(C#4)</div>
            </div>
            <div class="black-key" style="left: 522px;" data-note="D#4" data-key="d"> <!-- 102 + 420 -->
                <div class="key-label">(D#4)</div>
            </div>
            <div class="black-key" style="left: 642px;" data-note="F#4" data-key="g"> <!-- 222 + 420 -->
                <div class="key-label">(F#4)</div>
            </div>
            <div class="black-key" style="left: 702px;" data-note="G#4" data-key="h"> <!-- 282 + 420 -->
                <div class="key-label">(G#4)</div>
            </div>
            <div class="black-key" style="left: 762px;" data-note="A#4" data-key="j"> <!-- 342 + 420 -->
                <div class="key-label">(A#4)</div>
            </div>
            <!-- Upper Octave (C#5-A#5) - Keys: 2 3 5 6 7 -->
            <div class="black-key" style="left: 882px;" data-note="C#5" data-key="2"> <!-- 462 + 420 -->
                <div class="key-label">(C#5)</div>
            </div>
             <div class="black-key" style="left: 942px;" data-note="D#5" data-key="3"> <!-- 522 + 420 -->
                <div class="key-label">(D#5)</div>
            </div>
            <div class="black-key" style="left: 1062px;" data-note="F#5" data-key="5"> <!-- 642 + 420 -->
                <div class="key-label">(F#5)</div>
            </div>
            <div class="black-key" style="left: 1122px;" data-note="G#5" data-key="6"> <!-- 702 + 420 -->
                <div class="key-label">(G#5)</div>
            </div>
            <div class="black-key" style="left: 1182px;" data-note="A#5" data-key="7"> <!-- 762 + 420 -->
                <div class="key-label">(A#5)</div>
            </div>
        </div>
    </div>

    <!-- AI Interaction Section -->
    <div class="mt-8 max-w-xl w-full space-y-4">
        <div id="ai-feedback" class="mb-2 text-gray-600 italic text-center min-h-[1.5em]"></div>
        
        <div>
            <input type="text" id="ai-chat-input" class="w-full border border-gray-300 p-2 rounded shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="E.g., 'a sad melody in C minor with pauses'">
        </div>

        <div class="flex flex-col sm:flex-row justify-center space-y-2 sm:space-y-0 sm:space-x-3">
            <button id="ai-instruct-button" class="bg-green-500 hover:bg-green-700 text-white font-bold py-2 px-4 rounded">
                Generate & Play from Input
            </button>
            <button id="ai-random-play-button" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">
                Play Random Melody
            </button>
            <button id="replay-button" class="bg-purple-500 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded hidden">
                Play Again
            </button>
        </div>
    </div>

    <script>
        // Audio context setup
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        // Function to play a note
        function playNote(frequency, duration = 0.7) { // Increased default duration slightly
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.type = 'triangle'; // Changed from 'sine' for a richer sound
            oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
            
            // Simple ADSR-like envelope simulation
            const now = audioContext.currentTime;
            const attackTime = 0.01;  // Very short attack
            const decayTime = 0.1;   // Time to decay to sustain level
            const sustainLevel = 0.3; // Volume level during sustain
            const peakVolume = 0.6;   // Max volume during attack

            gainNode.gain.setValueAtTime(0, now); // Start silent
            gainNode.gain.linearRampToValueAtTime(peakVolume, now + attackTime); // Attack ramp
            gainNode.gain.exponentialRampToValueAtTime(sustainLevel, now + attackTime + decayTime); // Decay to sustain
            
            // Schedule the start of the release phase towards the end of the duration
            // The release will happen over the last part of the duration.
            // A more realistic approach would trigger release on key up.
            const releaseStartTime = now + duration * 0.8; // Start release slightly before the end 
            if (releaseStartTime > now + attackTime + decayTime) { // Ensure release starts after decay
                 gainNode.gain.setValueAtTime(sustainLevel, releaseStartTime);
                 gainNode.gain.exponentialRampToValueAtTime(0.001, now + duration); // Release ramp
            } else {
                // If duration is very short, just ramp down from decay
                 gainNode.gain.exponentialRampToValueAtTime(0.001, now + duration); 
            }
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.start(now);
            oscillator.stop(now + duration);
        }
        
        // Note frequencies (A4 = 440Hz)
        const noteFrequencies = {
            // Octave 3
            'C3': 130.81, 'C#3': 138.59, 'D3': 146.83, 'D#3': 155.56,
            'E3': 164.81, 'F3': 174.61, 'F#3': 185.00, 'G3': 196.00,
            'G#3': 207.65, 'A3': 220.00, 'A#3': 233.08, 'B3': 246.94,
            // Octave 4
            'C4': 261.63, 'C#4': 277.18, 'D4': 293.66, 'D#4': 311.13,
            'E4': 329.63, 'F4': 349.23, 'F#4': 369.99, 'G4': 392.00,
            'G#4': 415.30, 'A4': 440.00, 'A#4': 466.16, 'B4': 493.88,
            // Octave 5
            'C5': 523.25, 'C#5': 554.37, 'D5': 587.33, 'D#5': 622.25,
            'E5': 659.25, 'F5': 698.46, 'F#5': 739.99, 'G5': 783.99,
            'G#5': 830.61, 'A5': 880.00, 'A#5': 932.33, 'B5': 987.77
        };
        
        // Set up mouse events for piano keys
        document.querySelectorAll('.white-key, .black-key').forEach(key => {
            const note = key.getAttribute('data-note');
            const keyboardKey = key.getAttribute('data-key');
            
            // Mouse down
            key.addEventListener('mousedown', () => {
                key.classList.add('active');
                playNote(noteFrequencies[note]);
            });
            
            // Mouse up
            key.addEventListener('mouseup', () => {
                key.classList.remove('active');
            });
            
            // Mouse leave while pressed
            key.addEventListener('mouseleave', () => {
                if (key.classList.contains('active')) {
                    key.classList.remove('active');
                }
            });
        });
        
        // Set up keyboard events
        document.addEventListener('keydown', (e) => {
            // Prevent piano playing when chat input is focused
            if (document.activeElement === document.getElementById('ai-chat-input')) {
                return;
            }

            const key = e.key.toLowerCase();
            const pianoKey = document.querySelector(`[data-key="${key}"]`);
            
            if (pianoKey && !pianoKey.classList.contains('active')) {
                pianoKey.classList.add('active');
                const note = pianoKey.getAttribute('data-note');
                playNote(noteFrequencies[note]);
            }
        });
        
        document.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();
            const pianoKey = document.querySelector(`[data-key="${key}"]`);
            
            if (pianoKey) {
                pianoKey.classList.remove('active');
            }
        });
        
        // Handle mobile touch events
        document.querySelectorAll('.white-key, .black-key').forEach(key => {
            const note = key.getAttribute('data-note');
            
            key.addEventListener('touchstart', (e) => {
                e.preventDefault();
                key.classList.add('active');
                playNote(noteFrequencies[note]);
            });
            
            key.addEventListener('touchend', (e) => {
                e.preventDefault();
                key.classList.remove('active');
            });
        });

        // Helper function for delays
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // Function to play polyphonic OR monophonic sequences
        async function playSequence(sequence) {
            const baseDurationMs = 400; // Base duration for multiplier 1
            console.log("Starting sequence playback (mono/poly)...");

            for (const item of sequence) {
                // --- Basic validation (remains the same) --- 
                if (!Array.isArray(item) || item.length !== 2) {
                    console.warn("Skipping invalid item structure:", item);
                    continue;
                }
                const [eventData, multiplier] = item;
                if (typeof multiplier !== 'number' || multiplier <= 0) {
                    console.warn("Skipping item with invalid multiplier:", item);
                    continue;
                }
                const currentDurationMs = baseDurationMs * multiplier;

                // --- Determine notes/pause based on eventData structure --- 
                let notesToPlay = []; // Array of note names for this step
                let isPause = false;
                let isPoly = false;

                if (Array.isArray(eventData)) { // Polyphonic chord: [["Note1", "Note2"], multiplier]
                    if (eventData.length === 2 && typeof eventData[0] === 'string' && typeof eventData[1] === 'string') {
                        notesToPlay = eventData;
                        isPoly = true;
                    } else {
                        console.warn("Skipping invalid chord format:", item);
                        continue;
                    }
                } else if (typeof eventData === 'string') { // Monophonic: ["Note" or "PAUSE", multiplier]
                    if (eventData === "PAUSE") {
                        isPause = true;
                    } else {
                        notesToPlay = [eventData]; // Single note
                        isPoly = false;
                    }
                } else {
                    console.warn("Skipping invalid event data type:", item);
                    continue;
                }

                // --- Execute the step --- 
                if (isPause) {
                    console.log(`PAUSE for ${currentDurationMs}ms (Multiplier: ${multiplier})`);
                    await sleep(currentDurationMs);
                } else if (notesToPlay.length > 0) {
                    const notesString = notesToPlay.join(', ');
                    console.log(`Playing notes: ${notesString} for ${currentDurationMs}ms (Multiplier: ${multiplier})`);
                    const activeKeys = [];
                    
                    // Start all notes simultaneously & activate keys
                    for (const note of notesToPlay) {
                        const pianoKey = document.querySelector(`[data-note="${note}"]`);
                        if (pianoKey && noteFrequencies[note]) {
                            pianoKey.classList.add('active');
                            activeKeys.push(pianoKey); 
                            playNote(noteFrequencies[note], currentDurationMs / 1000);
                        } else {
                            console.warn(`Note ${note} in ${isPoly ? 'chord' : 'note'} not found or invalid.`);
                        }
                    }
                    
                    // Wait for the duration
                    await sleep(currentDurationMs);
                    
                    // Deactivate all keys for this step
                    for (const key of activeKeys) {
                        key.classList.remove('active');
                    }

                } else { 
                     await sleep(currentDurationMs); 
                }
            } // End of loop over sequence items

            console.log("Sequence finished.");
        }

        // --- AI Music Generation ---
        const deepseekApiKey = 'sk-add35bac795a45528576d6ae8ee2b5dc'; // WARNING: Exposing API key!
        const deepseekApiUrl = 'https://api.deepseek.com/chat/completions';
        const numberOfSegments = 3; // Number of segments to generate for a longer piece
        const contextLength = 4; // Number of items from previous segment to use as context

        const loadingTips = [
            "Play yourself while you wait...",
            "Did you know? The lowest note is C3.",
            "Try asking for a specific mood or key!",
            "The AI is composing, just a moment...",
            "Remember, you can play with keys ZXC... and QWE...",
            "What masterpiece will Keynius create now?",
            "Tip: Ask for polyphony using 'two hands' or 'chords'.",
            "Warming up the circuits...",
            "Thinking musically..."
        ];

        let lastGeneratedSequence = null; // To store the last successfully generated sequence

        // Main function to orchestrate segment generation and playback
        async function generateAndPlaySequence(userPrompt = null) {
            const buttonId = userPrompt ? 'ai-instruct-button' : 'ai-random-play-button';
            const button = document.getElementById(buttonId);
            const feedbackDiv = document.getElementById('ai-feedback');
            const replayButton = document.getElementById('replay-button'); // Get replay button
            const originalButtonText = button.textContent;
            
            // Hide replay button at the start of generation
            if(replayButton) replayButton.classList.add('hidden'); 

            button.disabled = true;
            button.classList.add('loading-indicator');
            // Display a random tip while loading
            const randomTip = loadingTips[Math.floor(Math.random() * loadingTips.length)];
            feedbackDiv.textContent = randomTip; 
            
            let fullSequence = [];
            let previousContext = [];
            let success = true;
            let suggestedTitle = null; // Variable to store the suggested title

            // --- Fetch title suggestion first (if applicable) --- 
            if (userPrompt) {
                try {
                    suggestedTitle = await fetchSongTitleSuggestion(userPrompt);
                } catch (titleError) {
                    // Log error but continue with music generation anyway
                    console.error("Failed to fetch title suggestion:", titleError);
                }
            }

            // --- Generate Segments --- 
            for (let i = 1; i <= numberOfSegments; i++) {
                button.textContent = `Generating segment ${i}/${numberOfSegments}`;
                console.log(`--- Requesting Segment ${i} ---`);
                try {
                    const segmentSequence = await fetchSegment(userPrompt, previousContext, i > 1);
                    if (segmentSequence && segmentSequence.length > 0) {
                        fullSequence.push(...segmentSequence); // Add segment to the full sequence
                        console.log(`Segment ${i} received, length: ${segmentSequence.length}. Total length: ${fullSequence.length}`);
                        // --- **Re-applying context update placement fix** ---
                        // Update context *after* adding the segment for the *next* iteration
                        previousContext = fullSequence.slice(-contextLength); 
                    } else {
                        // Handle case where segment is empty/invalid
                        feedbackDiv.textContent = `Failed to generate a valid segment ${i}. Stopping.`;
                        console.warn(`Segment ${i} generation failed or returned empty.`);
                        success = false;
                        break; // Stop generating further segments
                    }
                } catch (error) {
                    console.error(`Error fetching segment ${i}:`, error);
                    feedbackDiv.textContent = `Error during segment ${i}: ${error.message}. Stopping.`;
                    success = false;
                    break; // Stop on error
                }
            } // End of loop

            // --- Play the full sequence if generation was successful --- 
            if (success && fullSequence.length > 0) {
                // Store the sequence for replay
                lastGeneratedSequence = [...fullSequence]; // Store a copy
                // Show replay button
                if(replayButton) replayButton.classList.remove('hidden');

                 let feedbackMessage = "Okay, playing generated piece"; // Default message
                 if (userPrompt) {
                    // Clarify that the title is a suggestion and the piece is generated
                    feedbackMessage = `Okay, playing AI-generated piece inspired by: \"${userPrompt}\"`; 
                    if (suggestedTitle) {
                        // Use clearer wording for the suggestion
                        feedbackMessage += ` (AI suggested title: ${suggestedTitle})`; 
                    }
                 } else {
                    feedbackMessage = "Okay, playing generated random piece.";
                 }
                feedbackDiv.textContent = feedbackMessage;
                
                // Disable buttons during playback
                button.disabled = true;
                if(replayButton) replayButton.disabled = true;
                
                await playSequence(fullSequence); // Play the combined sequence

                // Re-enable buttons after playback
                button.disabled = false; 
                if(replayButton) replayButton.disabled = false;

            } else if (success && fullSequence.length === 0) {
                // If loop finished but sequence is still empty (shouldn't happen often with current logic)
                feedbackDiv.textContent = "Sorry, couldn't generate any music this time.";
            }
            // If !success, feedback is already set in the loop

            // --- Cleanup --- 
            button.disabled = false;
            button.textContent = originalButtonText;
            button.classList.remove('loading-indicator');
        }

        // Function to ask AI for a song title suggestion based on user prompt
        async function fetchSongTitleSuggestion(userPrompt) {
            if (!userPrompt) return null; // No prompt, no suggestion
            
            console.log("Requesting song title suggestion for:", userPrompt);
            const titlePrompt = `A user wants to hear music based on the request: \"${userPrompt}\". What specific, well-known song title could serve as inspiration for a short piano piece based on this request? Respond with ONLY the song title and artist (if applicable), like "Like a Prayer - Madonna" or "Für Elise". Do not include any other explanation, quotation marks, or formatting.`;

            try {
                const response = await fetch(deepseekApiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${deepseekApiKey}`
                    },
                    body: JSON.stringify({
                        model: 'deepseek-chat', 
                        messages: [
                            { role: 'system', content: 'You suggest relevant song titles based on user requests.' },
                            { role: 'user', content: titlePrompt }
                        ],
                        max_tokens: 50, // Short response needed
                        temperature: 0.5 // Less creative, more direct answer preferred
                    })
                });

                if (!response.ok) {
                    console.error(`Title suggestion API error: ${response.status} ${response.statusText}`);
                    return null;
                }

                const data = await response.json();

                if (data.choices && data.choices[0] && data.choices[0].message && data.choices[0].message.content) {
                    let suggestedTitle = data.choices[0].message.content.trim();
                    // Basic cleanup: remove potential quotes
                    suggestedTitle = suggestedTitle.replace(/^"|"$/g, ''); 
                    console.log("AI suggested title:", suggestedTitle);
                    return suggestedTitle;
                } else {
                    console.warn("Could not extract title suggestion from AI response.");
                    return null;
                }
            } catch (error) {
                console.error("Error fetching song title suggestion:", error);
                return null;
            }
        }

        // Function to fetch a single segment from the AI
        async function fetchSegment(userPrompt, context, isContinuation) {
            console.log(`Fetching segment. Continuation: ${isContinuation}. Context length: ${context.length}`);
            const availableNotes = Object.keys(noteFrequencies).join(', ');
            const baseDurationInfo = "Use a duration multiplier: 1 for standard (quarter), 2 for double (half), 0.5 for half (eighth), etc.";

            // --- Determine if polyphony is requested --- 
            let wantsPolyphony = false;
            if (userPrompt) {
                const polyKeywords = ['polyphonic', 'two hands', 'harmony', 'chord', 'tvåstämmig', 'ackord', 'två händer'];
                wantsPolyphony = polyKeywords.some(keyword => userPrompt.toLowerCase().includes(keyword));
            }
            console.log("Polyphony requested:", wantsPolyphony);

            // --- Define output formats and examples based on polyphony --- 
            let outputFormatInfo, example, systemMessage;
            if (wantsPolyphony) {
                outputFormatInfo = `Output the result as a JSON array of sequence items. Each item must be [\"Note\", mult], [\"PAUSE\", mult], or [[\"Note1\", \"Note2\"], mult] for simultaneous notes.`;
                example = `Example: [[\"E4\", 1], [[\"F4\",\"A4\"], 1], [\"PAUSE\", 1]]`;
                systemMessage = 'You are an AI music composer assistant generating polyphonic musical segments as JSON.';
            } else {
                outputFormatInfo = `Output the result as a JSON array of pairs. Each item must be [\"NoteName\", duration_multiplier] or [\"PAUSE\", duration_multiplier].`;
                example = `Example: [[\"E4\", 1], [\"F4\", 1], [\"PAUSE\", 1], [\"G4\", 2]]`; // Monophonic example
                systemMessage = 'You are an AI music composer assistant generating monophonic musical segments as JSON.';
            }

            // --- Construct the prompt --- 
            let promptSegment;
            const segmentLength = "(approx 4-8 measures)";
            const musicType = wantsPolyphony ? "polyphonic (two-handed)" : "monophonic (single voice)";

            if (isContinuation) {
                const contextString = JSON.stringify(context); 
                promptSegment = `Continue the ${musicType} musical piece based on the initial request: \"${userPrompt || 'play something random'}\". The previous segment ended with approximately: ${contextString}.`;
                promptSegment += ` Generate the *next* ${segmentLength} segment.`;
            } else {
                const baseRequest = userPrompt 
                                ? `Generate the *first* ${segmentLength} segment of a ${musicType} piece based on: \"${userPrompt}\".`
                                : `Generate the *first* ${segmentLength} segment of a simple, random ${musicType} piece.`;
                promptSegment = baseRequest;
                 if (userPrompt && (userPrompt.toLowerCase().includes('c minor') || userPrompt.toLowerCase().includes('c-moll'))) {
                    promptSegment += ` For C minor, primarily use C, D, Eb(D#), F, G, Ab(G#), Bb(A#).`;
                }
            }
            promptSegment += ` Use only available notes: ${availableNotes}. Include pauses ([\"PAUSE\", mult]).`;
            if (wantsPolyphony) {
                 promptSegment += ` Play simultaneous notes like [[\"N1\",\"N2\"], mult].`;
            }
            promptSegment += ` ${baseDurationInfo}`; 
            promptSegment += ` ${outputFormatInfo}`; 
            promptSegment += ` ${example}`; 
            promptSegment += ` Ensure all brackets [ ] are correctly opened and closed.`;
            promptSegment += ` Output ONLY the JSON array for this segment. No other text or markdown.`;
            
            console.log("Segment Prompt:", promptSegment);

            // --- Make the API call --- 
            try {
                const response = await fetch(deepseekApiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${deepseekApiKey}`
                    },
                    body: JSON.stringify({
                        model: 'deepseek-chat',
                        messages: [
                            { role: 'system', content: systemMessage }, 
                            { role: 'user', content: promptSegment }
                        ],
                        max_tokens: 800, 
                        temperature: 0.75 
                    })
                });

                if (!response.ok) {
                    throw new Error(`Deepseek API error: ${response.status} ${response.statusText}`);
                }

                const data = await response.json();
                
                // --- Parse the response --- 
                let segmentSequence = [];
                 if (data.choices && data.choices[0] && data.choices[0].message && data.choices[0].message.content) {
                    let rawContent = data.choices[0].message.content.trim();
                    console.log("Raw Segment Response:", rawContent);
                    // Remove markdown
                    if (rawContent.startsWith('```json')) rawContent = rawContent.substring(7).trim();
                    else if (rawContent.startsWith('```')) rawContent = rawContent.substring(3).trim();
                    if (rawContent.endsWith('```')) rawContent = rawContent.substring(0, rawContent.length - 3).trim();

                    // Parse JSON
                    const startIndex = rawContent.indexOf('[');
                    const endIndex = rawContent.lastIndexOf(']');
                    if (startIndex !== -1 && endIndex !== -1 && endIndex > startIndex) {
                        const jsonString = rawContent.substring(startIndex, endIndex + 1);
                        try {
                            segmentSequence = JSON.parse(jsonString);
                             // **Basic validation - check if it's an array**
                             if (!Array.isArray(segmentSequence)) {
                                console.warn("Parsed sequence is not an array.", segmentSequence);
                                segmentSequence = []; // Invalidate if structure is wrong
                             } // Further validation happens in playSequence
                        } catch (parseError) {
                            console.error("Failed to parse segment JSON:", parseError, "String:", jsonString);
                             segmentSequence = []; // Invalidate on parse error
                        }
                    } else {
                        console.warn("Could not find valid JSON brackets in segment response.");
                         segmentSequence = [];
                    }
                } else {
                    console.error("Unexpected segment response structure:", data);
                    segmentSequence = [];
                }
                return segmentSequence; 

            } catch (error) {
                console.error('Error in fetchSegment API call:', error);
                throw error; 
            }
        }

        // Add event listener to the RANDOM melody button
        document.getElementById('ai-random-play-button').addEventListener('click', () => {
             generateAndPlaySequence(); // Call without prompt for random melody
        });

        // Add event listener to the INSTRUCTED melody button
        document.getElementById('ai-instruct-button').addEventListener('click', () => {
            const userInput = document.getElementById('ai-chat-input').value;
            if (userInput.trim()) { // Only generate if input is not empty
                generateAndPlaySequence(userInput.trim());
            } else {
                alert("Please enter instructions for the AI composer.");
            }
        });

        // Clear chat input and feedback on page load
        document.addEventListener('DOMContentLoaded', (event) => {
            const chatInput = document.getElementById('ai-chat-input');
            if (chatInput) {
                chatInput.value = '';
            }
            const feedbackDiv = document.getElementById('ai-feedback');
            if (feedbackDiv) {
                feedbackDiv.textContent = ''; // Clear feedback too
            }
        });

        // Trigger AI generation on Enter key in chat input
        document.getElementById('ai-chat-input').addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault(); // Prevent default Enter behavior (like form submission)
                const userInput = e.target.value.trim();
                if (userInput) {
                    generateAndPlaySequence(userInput);
                } else {
                    // Optional: Notify user if input is empty on Enter
                    // alert("Please enter instructions before pressing Enter."); 
                    const feedbackDiv = document.getElementById('ai-feedback');
                    if(feedbackDiv) feedbackDiv.textContent = "Please enter instructions first.";
                }
            }
        });

        // Add event listener for the replay button
        document.getElementById('replay-button')?.addEventListener('click', async () => {
            const replayButton = document.getElementById('replay-button');
            const instructButton = document.getElementById('ai-instruct-button');
            const randomButton = document.getElementById('ai-random-play-button');
            const feedbackDiv = document.getElementById('ai-feedback');

            if (lastGeneratedSequence && lastGeneratedSequence.length > 0) {
                console.log("Replaying last sequence...");
                if(feedbackDiv) feedbackDiv.textContent = "Replaying the last generated piece...";

                // Disable buttons during replay
                if(replayButton) replayButton.disabled = true;
                if(instructButton) instructButton.disabled = true;
                if(randomButton) randomButton.disabled = true;
                
                await playSequence(lastGeneratedSequence);

                // Re-enable buttons after replay
                if(replayButton) replayButton.disabled = false;
                 if(instructButton) instructButton.disabled = false;
                if(randomButton) randomButton.disabled = false;
                if(feedbackDiv) feedbackDiv.textContent = "Replay finished.";

            } else {
                console.warn("No sequence available to replay.");
                 if(feedbackDiv) feedbackDiv.textContent = "Nothing generated yet to replay.";
            }
        });

    </script>
</body>
</html>